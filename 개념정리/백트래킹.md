# 백트래킹

일반적으로 그래프/트리의 모든 원소를 완전 탐색하기 위한 목적으로 사용할 수 있다.

> **DFS와의 차이점**
>
> 1. DFS는 일반적으로 완전 탐색 목적으로, 재귀 함수를 이용해 구현
> 2. 백트래킹도 재귀 함수를 이용해 구현하는 것이 일반적이지만, 단순히 완전 탐색하는 것이 아니라 조건에 따라서 **망한 노드**로 이동

## 동작 방식

그래프를 표현하는 2가지 방식

1. 인접 행렬
2. 인접 리스트

## [N-Queen](./n-Queen.js)

- N x N 체스 보드 위에 퀸 N개가 서로 공격할 수 없게 놓는 문제

```
N = 8 이라면

- 64개의 위치에 8개의 퀸을 설치하는 모든 조합의 수는 Combination(64,8)
- 단순히 모든 경우의 수를 전부고려하면 경우의 수가 너무 커지기 때문에 **유망한 경우에만 탐색** => 백트래킹 방식 사용

1. 각 행마다 1개씩의 퀸을 놓는다. (N개의 퀸)
2. 첫 번째 행부터 퀸을 하나씩 놓는다.
   - 8개의 행에 놓을수 있는 퀸의 경우의수 = 2^3을 8번 곱한, 2^24개의 경우
3. 하나의 퀸 A가 이미 존재하는 상태에서, 다른 퀸 B를 놓으려면?
   - 퀸 A의 상하좌우 및 대각선 위치가 아닌 위치에 퀸 B를 놓을 수 있다.
```

- 트리구조를 사용하여 이미 놓아진 퀸 A 상태를 가진채로 퀸 B를 고려한다.

- 가능한 모든 조합의 수를 구하는 것과 같다.
- 매 재귀함수 마다 실제로 N x N 모든 위치를 모두 볼 필요가 없다

맨 처음 행(row)부터 차례대로 퀸을 놓는 다고 생각하면 가짓수를 훨씬 줄일 수 있다.

- N-Queen문제는 가능한 조합을 계산하는 것이므로, **현재 행의 이전행으로 돌아갈 필요가 없다.**

> ##### 백트래킹을 진행할때 경우의 수를 최대한 줄이는 방법.
>
> - **이전까지 놓았던 퀸들과 상충되지 않는 조건**을 만족하는 위치에 대해서만 재귀 함수를 호출
>   1.  재귀 함수를 통해 모든 경우의 수를 다 찾은 뒤, 각 경우마다 가능한지 검사하는 방법
>   2.  유망한 경우에 대해서만 재귀함수를 호출하는 방법

- 특정 위치(노드)의 가능 여부를 판단할 필요가 있다.
  1. 같은 행에 있는지 체크 : x1 == x2 / 같은 열에 있는지 체크 : y1 == y2
  2. 대각선에 있는지 체크 : abs(x1-x2) == abs(y1-y2)

## 백트래킹의 기본 형태

```js
function recursive(){
    if 종료 조건을 만족한다면 {
        처리;
    }
    for 자식 노드를 하나씩 확인하며 {
        if 임의의 조건을 만족한다면 {
            자식 노드 방문 처리;
            재귀 함수 recursive() 호출;
            자식 노드 방문 처리 해제;
        }
    }
}
```

- 루트 노드에서 자식 노드로 내려간다.

### N-Queen 예시 코드

```js
// 체스판의 크기를 정의합니다. 이 경우 8x8 체스판입니다.
let n = 8;

// queens 배열은 현재 체스판에 배치된 퀸들의 위치를 저장합니다.
let queens = [];

// possible 함수는 특정 위치에 퀸을 놓을 수 있는지를 검사합니다.
function possible(x, y) {
  // 현재 배치된 모든 퀸들의 위치를 확인합니다.
  for (let [a, b] of queens) {
    // 만약 같은 행(x) 또는 같은 열(y)에 이미 퀸이 있다면 false를 반환합니다.
    if (a == x || b == y) return false;

    // 대각선상에 퀸이 있는지도 확인합니다. 대각선상의 퀸은 행과 열의 차이가 같을 때입니다.
    if (Math.abs(a - x) == Math.abs(b - y)) return false;
  }

  // 위 조건들을 모두 통과하면 해당 위치에 퀸을 놓을 수 있으므로 true를 반환합니다.
  return true;
}

// 가능한 모든 퀸의 배치 방법의 수를 세는 변수입니다.
let count = 0;

// dfs 함수는 깊이 우선 탐(Depth-first search)색을 통해 퀸을 배치합니다.
function dfs(row) {
  // 모든 행에 퀸을 배치했다면 하나의 해를 찾은 것이므로 count를 증가시킵니다.
  if (row == n) {
    count += 1;
    return;
  }

  // 현재 행의 모든 열에 대해 퀸을 놓아보며 가능한지 확인합니다.
  for (let i = 0; i < n; i++) {
    // 만약 현재 위치에 퀸을 놓을 수 없다면, 다음 열로 넘어갑니다.
    if (!possible(row, i)) continue;

    // 현재 위치에 퀸을 놓을 수 있다면, queens 배열에 퀸의 위치를 추가합니다.
    queens.push([row, i]);

    // 다음 행에 대해 같은 과정을 반복합니다.
    dfs(row + 1);

    // 현재 위치에서 퀸을 제거하고, 다른 위치에 퀸을 놓는 경우를 탐색합니다 (백트래킹).
    queens.pop();
  }
}

// 첫 번째 행에서 탐색을 시작합니다.
dfs(0);

// 모든 가능한 퀸의 배치 방법의 수를 출력합니다.
console.log(count);
```
